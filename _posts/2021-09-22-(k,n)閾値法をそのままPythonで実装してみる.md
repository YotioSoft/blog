---
layout: post
title: (k,n)閾値法をそのままPythonで実装してみる
tags: [Python]
excerpt_separator: <!--more-->
---

先日、大学の講義で扱われた「秘密分散法」という手法の仕組みがとても興味深かったので、実際にPythonで実装してみました。

<!--more-->



# 秘密分散法とは

一言で言えば暗号化の手法の一つ。暗号化したい平文を複数の「シェア（分散片とも言う）」と呼ばれるデータに分散して保管することで、頑強性と秘匿性が確保されます。

## (k,n)閾値法

秘密分散法のアルゴリズムの1つで、平文をn個のシェアに分散し、k個（任意の数）以上のシェアが揃えば復元できるようにする手法。つまり、分割したシェアのうち、全てが集まらなくても、k個集まればk個のシェアから1つの平文に復元できるというわけです。よってn-k個のシェアを紛失しても復元できるので、頑強性が確保されます。また、シェアがk個未満しか集まらなかった場合、復元はできないので秘匿性が確保されます。

## (k,n)閾値法のアルゴリズム（加法）

例として、(2,3)閾値法で考えてみます。つまり、k=2、n=3なので、合計3個のシェアがあって2個以上のシェアで復元できます。また、平文は仮にS=4649とします。

### 1. 有限体を作る

まずは要素数p（ただし、p>nでpは素数）の有限体

$ F_p $

を作ります。  

$$ F_p=\{0,1,...,p-2,p-1\} $$

ここでは仮にp=5とします。  
$$ F_p=\{0,1,2,3,4\} $$

### 2. シェアを生成する

n=3個のシェアを生成します。i番目のシェア

$ W_i $

は次の数式で表されます。

$$ W_i=f(α_i)=S+A_1α_i+A_2α_i^2+…+A_{k-1}α_i^{k-1}, i=1, 2, ..., n $$

ここで、

$ A_1，A_2… $

は有限体

$ F_p $

の中からランダムに選びます。  

上記のシェアをn個分生成します。このとき、$ α_i $は0以外の$ F_p $の相異なる元とします。つまり、今回のようにp=5の場合、_

_$ α_i ∈ {1, 2, 3, 4} $

であり、

$ α_i $_

_は1〜4のいずれかの値を取ります。さらに、_

_$ α_i $

は他のシェアのものと同じ値をとってはいけないというわけです。

今回は以下のようにn=3個のシェア

$ W_1 $

〜

$ W_3 $

を生成しました。

$$ A_1 = 3 $$

$$ α_1 = 1 $$

$$ α_2 = 2 $$

$$ α_3 = 3 $$

$$ W_1=F(α_1)=S+A_1α_1=4649+3×1=4652 $$

$$ W_2=F(α_2)=S+A_1α_2=4649+3×2=4655 $$

$$ W_3=F(α_3)=S+A_1α_3=4649+3×3=4658 $$

### 3. 復元する

復元する上ではラグランジュ補間を用います。

$$ f(t)=\sum_{j=1}^kf(α_{i_j})\frac{(t-α_{i_1})…(t-α_{i_{j-1}})(t-α_{i_{j+1}})…(t-α_{i_k})}{(α_{i_j}-α_{i_1})…(α_{i_j}-α_{i_{j-1}})(α_{i_j}-α_{i_{j+1}})…(α_{i_j}-α_{i_k})} $$

ここで、t=0（つまり、切片を求める）とすることで復元できます。  

実際に復元してみます。

$$ f(0)=\sum_{j=1}^2f(α_{i_1})\frac{(0-α_{i_1})…(0-α_{i_{j-1}})(0-α_{i_{j+1}})…(0-α_{i_k})}{(α_{i_j}-α_{i_1})…(α_{i_j}-α_{i_{j-1}})(α_{i_j}-α_{i_{j+1}})…(α_{i_j}-α_{i_k})} $$
$$ =4652×\frac{(-α_2)(-α_3)}{(α_1-α_2)(α_1-α_3)}+4655×\frac{(-α_1)(-α_3)}{(α_2-α_1)(α_2-α_3)}+4658×\frac{(-α_1)(-α_2)}{(α_3-α_1)(α_3-α_2)} $$
$$ =4652×\frac{(-2)×(-3)}{(-1)(-2)}+4655×\frac{(-1)×(-3)}{1×(-1)}+4658×\frac{(-1)×(-2)}{2×1} $$
$$ =4652×\frac{6}{2}+4655×\frac{3}{-1}+4658×\frac{2}{2} $$
$$ =4649 $$

平文である「4649」が復元できました。

## なぜ復元できるのか？

グラフで表してみれば簡単です。

$ (k,n)=(2,3) $

で考えてみます。例えば次の1次直線。  
![スクリーンショット 2021-09-22 23.03.12](../../../assets/img/post/スクリーンショット 2021-09-22 23.03.12.png)  
3つの点(1, 2)、(2, 4)、(3, 6)が与えられていれば簡単に1次式を導けます。答えは$ y=2x $です。  

2つの点(1, 2)と(2, 4)、あるいは(1, 2)と(3, 6)でも1次式を導けます。  
![スクリーンショット 2021-09-22 23.01.30](../../../assets/img/post/スクリーンショット 2021-09-22 23.01.30-2319354.png)  

しかし、もし1つの点(1, 2)しか与えられていなかったら？  
 ![スクリーンショット 2021-09-22 22.57.09](../../../assets/img/post/スクリーンショット 2021-09-22 22.57.09-2319077.png)  
直線の引き方は無数にあります。k>1であるので復元できません。  
![スクリーンショット 2021-09-22 22.57.10](../../../assets/img/post/スクリーンショット 2021-09-22 22.57.10.png)  
よって、k個以上のシェアが得られないと復元できないというわけです。

ラグランジュ補間は与えられた座標を通る式を導くための手法です。k=2個以上の座標を与えてやると

$ y=2x $

が導けます。

# Pythonで実装してみる

ここからが本題です。上記のアルゴリズムをPythonで実装してみます。  

## まずは基本から

上記の定義の通りにして実装します。  

```python
# 初期値
n = 3       # シェアの個数
k = 2       # 復元に必要なシェアの個数
S = 4649    # 平文
p = 5       # 有限体の個数（素数）

print("シェアの個数n =", n, "復元に必要なシェアの個数k =", k)
print("平文S =", S, "有限体の要素数p =", p)

# 有限体を生成する
# Fp = [0, 1, 2, ..., p-2, p-1]
Fp = range(0, p)
print("有限体Fp =", Fp)

# Aの値を設定
A = [3]
print("A =", A)

# αの値を設定
alpha = [1, 2, 3]
print("alpha =", alpha)

# シェアを生成する
W = []
for i in range(n):
    w_i = S
    for j in range(k - 1):
        w_i += A[j] * pow(alpha[i], j + 1)
    W.append(w_i)

print("Shares: ", str(W))

# 復元する
Y = 0  # 復号した文
nums = k  # 復号に用いるシェアの数（k以上n以下）
for i in range(nums):
    # 分子部の計算
    numerator = 1
    for j in range(nums):
        if j == i:
            continue
        numerator *= -alpha[j]

    # 分母部の計算
    demominator = 1
    for j in range(nums):
        if j == i:
            continue
        demominator *= alpha[i] - alpha[j]

    # Yに加算
    Y += W[i] * numerator / demominator

# 復元結果
print("復元後：Y =", Y)
```

```
シェアの個数n = 3 復元に必要なシェアの個数k = 2
平文S = 4649 有限体の要素数p = 5
有限体Fp = range(0, 5)
A = [3]
alpha = [1, 2, 3]
Shares:  [4652, 4655, 4658]
復元後：Y = 4649.0
```

うまい具合に動いているようです。

## 乱数を含めてみる

```python
import random

# 初期値
n = 3       # シェアの個数
k = 2       # 復元に必要なシェアの個数
S = 4649    # 平文
p = 5       # 有限体の個数（素数）

print("シェアの個数n =", n, "復元に必要なシェアの個数k =", k)
print("平文S =", S, "有限体の要素数p =", p)

# 有限体を生成する
# Fp = [0, 1, 2, ..., p-2, p-1]
Fp = range(0, p)
print("有限体Fp =", Fp)

# 係数Aをランダムに選ぶ
A = random.sample(Fp, k - 1)
print("A =", A)

# αをランダムに選ぶ
alpha = random.sample(Fp[1:], n)
print("alpha =", alpha)

# シェアを生成する
W = []
for i in range(n):
    w_i = S
    for j in range(k - 1):
        w_i += A[j] * pow(alpha[i], j + 1)
    W.append(w_i)

print("Shares: ", str(W))

# 復元する
Y = 0  # 復号した文
nums = k  # 復号に用いるシェアの数（k以上n以下）
for i in range(nums):
    # 分子部の計算
    numerator = 1
    for j in range(nums):
        if j == i:
            continue
        numerator *= -alpha[j]

    # 分母部の計算
    demominator = 1
    for j in range(nums):
        if j == i:
            continue
        demominator *= alpha[i] - alpha[j]

    # Yに加算
    Y += W[i] * numerator / demominator

# 復元結果
print("復元後：Y =", Y)
```

今回は乱数を含むので、動作確認のため何度か実行してみました。

```
シェアの個数n = 3 復元に必要なシェアの個数k = 2
平文S = 4649 有限体の要素数p = 5
有限体Fp = range(0, 5)
A = [1]
alpha = [2, 3, 1]
Shares:  [4651, 4652, 4650]
復元後：Y = 4649.0
```

```
シェアの個数n = 3 復元に必要なシェアの個数k = 2
平文S = 4649 有限体の要素数p = 5
有限体Fp = range(0, 5)
A = [2]
alpha = [4, 2, 1]
Shares:  [4657, 4653, 4651]
復元後：Y = 4649.0
```

```
シェアの個数n = 3 復元に必要なシェアの個数k = 2
平文S = 4649 有限体の要素数p = 5
有限体Fp = range(0, 5)
A = [1]
alpha = [2, 3, 1]
Shares:  [4651, 4652, 4650]
復元後：Y = 4649.0
```

```
シェアの個数n = 3 復元に必要なシェアの個数k = 2
平文S = 4649 有限体の要素数p = 5
有限体Fp = range(0, 5)
A = [4]
alpha = [3, 1, 4]
Shares:  [4661, 4653, 4665]
復元後：Y = 4649.0
```

いずれもk = 2個のシェアで正しく復元できています。

## ここで問題が…

では、nとkを大きくしてみたらどうか？と試してみたら、なんと復元後の値に誤差が出始めてしまった。因みにp>nなのでpも同時に大きくしています。   

```python
# 初期値
n = 11      # シェアの個数
k = 7       # 復元に必要なシェアの個数
S = 4649    # 平文
p = 13      # 有限体の個数（素数）
```

```
シェアの個数n = 11 復元に必要なシェアの個数k = 7
平文S = 4649 有限体の要素数p = 13
有限体Fp = range(0, 13)
A = [4, 11, 3, 1, 12, 9]
alpha = [5, 8, 2, 11, 12, 3, 6, 10, 9, 7, 4]
Shares:  [184069, 2763529, 5701, 17901319, 29892041, 14399, 520229, 10218789, 5505881, 1269171, 54441]
復元後：Y = 4648.999999996275
```

```
シェアの個数n = 11 復元に必要なシェアの個数k = 7
平文S = 4649 有限体の要素数p = 13
有限体Fp = range(0, 13)
A = [2, 3, 11, 12, 6, 1]
alpha = [4, 3, 10, 8, 9, 11, 6, 7, 5, 12, 1]
Shares:  [18721, 8138, 1735969, 518393, 977396, 2933234, 116009, 255886, 47984, 4751921, 4684]
復元後：Y = 4648.999999970198
```


さらに大きくしてみると…   

```python
# 初期値
n = 97      # シェアの個数
k = 17      # 復元に必要なシェアの個数
S = 4649    # 平文
p = 101     # 有限体の個数（素数）
```

```
シェアの個数n = 97 復元に必要なシェアの個数k = 17
平文S = 4649 有限体の要素数p = 101
有限体Fp = range(0, 101)
A = [63, 45, 60, 93, 10, 34, 9, 61, 85, 92, 8, 11, 95, 40, 42, 6]
alpha = [54, 65, 73, 99, 13, 2, 96, 86, 3, 12, 26, 40, 76, 31, 17, 23, 5, 56, 36, 48, 10, 50, 19, 20, 98, 14, 68, 58, 51, 72, 91, 22, 94, 52, 9, 89, 75, 1, 71, 53, 16, 69, 32, 43, 39, 11, 92, 81, 78, 64, 29, 74, 41, 60, 7, 47, 33, 42, 62, 37, 59, 46, 66, 24, 77, 18, 4, 100, 83, 45, 57, 25, 28, 21, 93, 79, 82, 80, 35, 6, 27, 85, 30, 49, 55, 8, 63, 84, 44, 88, 97, 87, 70, 15, 90, 61, 34]
Shares:  [35506201831898255806357214519, 675810479610164692650094862619, 4281498173050289696421004162971, 547352958156944760371102129605859, 6328859603323258971, 3428427, 335240846789012934445456290774473, 58141043441894655505208261223063, 1218543971, 1818031735403972717, 334914550826641164238803, 303932878504992744689999169, 8126552075752098527950930871853, 5382686103711589171016883, 419871846394161116187, 48506191943452499917971, 2561538837339, 63265494012253305523651338033, 57298967761045251722509013, 5473713702114474002362921721, 106962811225999779, 10462588182980906003713870299, 2404236988439108328099, 5381782081575343383909, 465607305859423324276596399172971, 20122147705177512639, 1384947703863431892853380535221, 110479899360407130022109329971, 14326996928755697774377767203, 3437884692879574703088341498657, 142998415369384168639165940418243, 24093020270197642293207, 239719294573478083411249984317999, 19500206244072831202018871877, 20925811809479579, 100373800304457913444456317136539, 6582176042554566562370692762499, 5403, 2752080103389226815511956106323, 26387051513489692077663898971, 162416657585315840793, 1746915832101513700386862244699, 8891011679142483380325897, 956240208146940130148083971, 203510713868441266661993939, 469651858482591363, 170188352634472352324112488814237, 22404080163855143990063540166683, 12286805871165591013434314201471, 528164933892285543348450816489, 1876785888051527918832219, 5316310511586313935019435753059, 449473622464306141854892443, 189340252406590299327138410429, 435326399774547, 3919311642904679053476920307, 14463247916686408879794971, 658522738505769363191926787, 318843727321012643733866857167, 88413510556884321487583067, 144960003188236017739047898179, 2786389629282139520639739423, 861500024213694466986219032843, 94828569788603641296209, 10005818733585824758500478939227, 1028980394152054638971, 88320903669, 642409511089285610934109360460949, 33034189727407271937397476439971, 1966269897570398869404064859, 83806958163921492668692334747, 180446295308901258003099, 1078410338899844093440221, 11589066515833822642523, 202169037749397457433791571898971, 15048556209369699133899960456819, 27236862764222119220138624332347, 18384357448223458893270784297689, 36687643896824577392426979, 41083134546983, 607443259562135821337027, 48261786993770054678651325356379, 3206109880456979035997039, 7592511755919915869461535259, 47519097430655347906263806739, 3395678029178721, 411186004688490460450500273971, 39973414815456963291442983016229, 1376795755244308576600675149, 83843708425732685484103511912721, 395416277986036876541300397684507, 69892641371054773443325329701267, 2196178508544311784499096739559, 59156151988342223219, 119922563956513258952284498844819, 246225092956520324634779459163, 23191869362314640839646379]
復元後：Y = 5980637394225.883
```

```
シェアの個数n = 97 復元に必要なシェアの個数k = 17
平文S = 4649 有限体の要素数p = 101
有限体Fp = range(0, 101)
A = [5, 84, 14, 45, 63, 12, 19, 94, 40, 0, 95, 9, 29, 42, 59, 74]
alpha = [35, 38, 48, 14, 85, 4, 34, 9, 74, 45, 65, 13, 41, 99, 75, 64, 47, 30, 43, 31, 17, 24, 100, 10, 40, 95, 51, 67, 29, 91, 76, 15, 70, 27, 98, 6, 19, 49, 39, 79, 23, 92, 86, 93, 46, 12, 78, 52, 82, 88, 37, 22, 28, 60, 97, 57, 50, 44, 33, 59, 96, 94, 55, 8, 89, 83, 20, 3, 68, 87, 26, 63, 25, 11, 80, 36, 18, 21, 77, 1, 58, 84, 69, 42, 62, 81, 90, 32, 16, 72, 5, 61, 7, 56, 71, 53, 54]
Shares:  [383975256412952772861067349, 1428753708127240313876780663, 59752048346379972443713808153, 170837682572099612735, 554655452400142789491641988100349, 394965337085, 241642633927227284488778435, 150311152871743685, 60483702644397830473606439135435, 21300054485950912744212766349, 7606736460335389943728635057749, 52435330393814276813, 4811539199167500688689621893, 6351898375906318021082045293705685, 74963205565421555734421684118149, 5936743700748179867888768602985, 42679002779888488651688881133, 32721716343184919245808399, 10300038518160022374114721733, 55246270724841096479626253, 3777178765154576455733, 927322505990278041441185, 7459422909950040941912634514845149, 803508549608777099, 3242773647993696967079435249, 3284477848189388356647373986238349, 157465723236394484766453828533, 12348692171758632318067244947733, 19040160536468177872327085, 1650867548217703062951367016165093, 92645462923644218262917468140133, 513182491631200392749, 24875351528668218188901327768599, 6081736238312274083096933, 5399997477044075769347342691161603, 240227726450903, 22275159917020405962485, 83077062738397997467274557685, 2163794570502941612030583485, 172054372358651092510989954247085, 470046453660940884057053, 1966135959361506634157988637783733, 668725643179195961210617801314023, 2337193875103284315120929577797933, 30264687150762234574446634463, 14647627887842365733, 140346808530410172524618289585023, 214775400932678867184982301933, 312242688012237324174514639768883, 965835893156398436864323531302113, 933034857697434073850704733, 231186363985923212649383, 10870941484583821253555573, 2115695185735923846027687331349, 4583115005722188451559794024762133, 931832409360427950657227548133, 114741567602620874426220714899, 14873072501483618115711660485, 149985204608058389346572693, 1617201490836400780270496155685, 3883203613639588699674881843323913, 2773149890162107167616787540102735, 526461422906674848713122485149, 23107128612000593, 1157114048784330213777198320952485, 379025868526692461499890420811893, 50501196822911696950349, 4302253973, 15649123264440348735792921302333, 804515067277550652698324978512733, 3328787855903759089710683, 4615345759798986189229401112013, 1779503393340268455354149, 3663743768896627973, 210385992643744388384763297310649, 602247204996504675014204573, 9400939650903499024883, 110022123724593622111613, 114182257061311006184548515641933, 5333, 1230501439856169933582385666043, 459026660649142491288510166156685, 19763250724030963290460269363485, 7071748441739509270340765483, 3573650108021249317946343159983, 256615849823303018394987952214453, 1383479339053349479598753774041499, 91740136191164093019218633, 1436242661255438812793, 39028503614320544541743404991633, 13390741749149, 2755591616211925262855819256173, 2770952733499133, 702195831615859909496884620353, 31207851510246760354991142194813, 291217719780191594917211322173, 392628319247683184627356203335]
復元後：Y = -2.305843009213694e+18
```

これはひどい。誤差が大きい上にブレまくりではないですか…   

kを小さくした場合はnやpが大きくても誤差は小さく済みました。   

```python
# 初期値
n = 97      # シェアの個数
k = 3       # 復元に必要なシェアの個数
S = 4649    # 平文
p = 101     # 有限体の個数（素数）
```

```
シェアの個数n = 97 復元に必要なシェアの個数k = 3
平文S = 4649 有限体の要素数p = 101
有限体Fp = range(0, 101)
A = [60, 92]
alpha = [28, 64, 81, 97, 39, 27, 75, 16, 71, 92, 70, 35, 67, 60, 23, 18, 8, 74, 42, 32, 2, 61, 34, 12, 51, 91, 45, 100, 98, 79, 62, 20, 36, 99, 88, 31, 73, 17, 22, 46, 87, 30, 37, 56, 25, 78, 40, 80, 82, 5, 26, 15, 93, 9, 49, 11, 69, 33, 57, 68, 66, 53, 3, 52, 7, 38, 94, 41, 63, 1, 4, 54, 76, 83, 90, 65, 86, 44, 95, 58, 10, 48, 47, 43, 24, 13, 50, 77, 19, 72, 55, 21, 96, 84, 6, 59, 89]
Shares:  [78457, 385321, 613121, 876097, 146921, 73337, 526649, 29161, 472681, 788857, 459649, 119449, 421657, 339449, 54697, 35537, 11017, 512881, 169457, 100777, 5137, 350641, 113041, 18617, 247001, 771961, 193649, 930649, 894097, 583561, 362017, 42649, 126041, 912281, 722377, 94921, 499297, 32257, 50497, 202081, 706217, 89249, 132817, 296521, 63649, 569057, 154249, 598249, 628177, 7249, 68401, 26249, 805937, 12641, 228481, 16441, 446801, 106817, 306977, 434137, 409361, 266257, 5657, 256537, 9577, 139777, 823201, 161761, 373577, 4801, 6361, 276161, 540601, 643417, 755249, 397249, 690241, 185401, 840649, 317617, 14449, 219497, 210697, 177337, 59081, 20977, 237649, 554737, 39001, 485897, 286249, 46481, 858281, 658841, 8321, 328441, 738721]
復元後：Y = 4649.0
```

## 誤差の原因

計算上の丸め誤差が原因かと思われます。累乗によって増大化した数値同士の除算を伴いますから、まぁ特に何も工夫せずにそのまま実装したらこうなるのかな…   
kが少ないほどシェアの数値が小さく、さらに演算回数も少なくて済むので、その分誤差が小さくなっているのでしょう。   

# おわりに

とりあえず実装はできました。が、k=2程度でないと使い物にならない出来の悪いプログラムになってしまいました。改善できたらまた記事に書きます。   
気が向いたら秘密分散法でファイルを分散保存するプログラムとか自作してみたいと思います。
